<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>All-in-one-converter </title>

  <style>
    /* Root color variables. These let you change theme easily. */
    :root{
      --bg1:#87CEEB;   /* sky-blue gradient start */
      --bg2:#ff4b2b;   /* orange gradient end */
      --accent:#5eead4;/* mint accent color used for buttons */
      --text:#f8f5f6;  /* default text color */
      
      /* Base color for the cards (e.g., 'black') */
      --card-color-name: black; 
      
      /* üîë CONTROLS CARD TRANSPARENCY: 70% transparency (30% opaque) üîë */
      --card-opacity-pct: 70%; 
      
      /* üîë CONTROLS INNER FILE LIST TRANSPARENCY: 10% transparency (90% opaque) üîë */
      --list-opacity-pct: 80%;
    }

    /* Box sizing: makes width/height easier to reason about */
    *{ box-sizing: border-box; }

    /* Base page styles */
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu;
      /* gradient background using variables above */
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: var(--text);
      transition: background 0.45s;
    }

    /* Optional full-photo background toggle; class 'bg-image' adds an image */
    body.bg-image{
      background: url('https://mrdesigner-create.github.io/photoes/Beautiful-Rose.jpg') center/cover no-repeat fixed;
    }

    /* Header spacing and text sizing */
    header{ padding: 32px 16px; text-align:center; }
    h1{ margin: 0 0 8px; font-size: clamp(24px, 3.3vw, 38px); }

    .subtitle{ opacity: .9; }

    /* Main page wrapper width and padding */
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 0 16px 64px; }

    /* Responsive grid: cards flow and wrap, min-width 300px */
    .grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:18px; }

    /* Card style: semi-transparent dark card with rounded corners and shadow */
    .card{
      /* Use color-mix with transparency variable */
      background: color-mix(in srgb, var(--card-color-name), transparent var(--card-opacity-pct));
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
      transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
      transform: translateZ(0); 
    }
    .card:hover {
      /* Subtle 3D tilt and lift when mouse hovers */
      transform: perspective(1000px) rotateX(1deg) rotateY(1deg) scale(1.02);
      box-shadow: 0 16px 40px rgba(0,0,0,.5); 
    }
    .card h3{ margin:4px 0 12px 0; }

    /* Dropzone UI element for file picking or drag/drop */
    .dropzone{
      width:100%;
      padding:12px;
      border:2px dashed rgba(255,255,255,.3);
      border-radius:12px;
      text-align:center;
      cursor:pointer;
      user-select:none;
    }
    .dropzone.dragover{ border-color: var(--accent); background: rgba(94,234,212,.08); }

    /* Native file input is hidden (we click label to open it) */
    input[type=file]{ display:none; }

    /* Primary buttons */
    button{
      cursor:pointer;
      border:none;
      padding:10px 14px;
      border-radius:12px;
      background: var(--accent);
      color:#06161a;
      font-weight:700;
      margin-top:5px;
    }
    /* Secondary (muted) button */
    button.secondary{ background:#94a3b8; color:#0b1020; }

    /* File list area inside each card */
    .file-list{
      margin-top:10px;
      font-size:13px;
      max-height:140px;
      overflow:auto;
      /* Use color-mix with list transparency variable */
      background: color-mix(in srgb, var(--card-color-name), transparent var(--list-opacity-pct));
      padding:8px;
      border-radius:8px;
    }
    .file-item{ display:flex; justify-content:space-between; padding:6px; border-bottom:1px solid rgba(255,255,255,.08); align-items:center; }
    .file-item .meta{ max-width:60%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* Fullscreen overlay used when user clicks 'Fullscreen' button */
    .overlay{
      position:fixed; left:0; top:0; width:100%; height:100%;
      background: rgba(0,0,0,.7);
      display:none; align-items:center; justify-content:center; z-index:9999;
    }
    .overlay.open{ display:flex; }
    .overlay .box{
      background:white; color:black;
      /* MODIFIED: Use viewport units for near-fullscreen display */
      width: 95vw; 
      height: 95vh;
      max-width: 98vw; /* Allow it to grow close to edges */
      max-height: 98vh; /* Allow it to grow close to edges */
      overflow:auto;
      padding:18px; 
      border-radius:12px; 
      box-shadow:0 0 20px rgba(0,0,0,.4);
      /* REQUESTED: Set base font size to 12px */
      font-size: 12px; 
    }
    .overlay h2{ margin-top:0; }

    /* Toggle background button in top-right */
    .toggle-bg{
      position:fixed; top:10px; right:10px; padding:8px 14px;
      background:var(--accent); border-radius:8px; font-weight:700; cursor:pointer;
      z-index:10000; color:#111;
    }

    /* Preview thumbnails row */
    .preview-row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
    .preview-card{
      width:150px; background:#fafafa; border-radius:8px; padding:8px;
      box-shadow:0 4px 12px rgba(0,0,0,.06); text-align:center; cursor:grab; color:#111;
    }
    .preview-card.dragging{ opacity:.5; }
    .preview-card img{ max-width:100%; max-height:90px; display:block; margin:0 auto 6px; }
    .preview-card canvas{ max-width:100%; height:auto; display:block; margin:0 auto 6px; }
    .preview-actions{ display:flex; gap:8px; justify-content:center; margin-top:6px; }
    
    /* New style for clickable cards with edits */
    .preview-card.individual-edit{
      border: 2px solid var(--accent);
      cursor: pointer;
    }
    
    /* Minor helper classes */
    /* MODIFIED: Changed from 13px to 12px for consistency */
    .muted{ color:#666; font-size:12px; } 
    .light-list{ margin-top:12px; }
    .list-row{
      display:flex; justify-content:space-between; padding:8px;
      border-bottom:1px solid #eee; background:#fff; border-radius:4px; margin-bottom:6px; align-items:center;
    }
    .drag-handle{ cursor:grab; padding:6px; background:#eee; border-radius:6px; margin-right:8px; }
    .controls{ display:flex; gap:12px; align-items:center; margin-top:12px; flex-wrap:wrap; }
    .control-group{ background:#f7f7f7; padding:8px; border-radius:8px; color:#111; }
    .slider{ width:160px; }
    .small{ font-size:13px; }
    .badge{ display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px; background:rgba(94,234,212,.15); color:var(--accent); font-size:12px; font-weight:700; }
    .hint{ font-size:12px; opacity:.9; }
    .notice{ font-size:12px; margin-top:6px; }
    .success{ color:#86efac; }
    .error{ color:#fca5a5; }

    /* Footer layout rules ‚Äî keep page height and push footer to bottom */
    html, body { height: 100%; margin: 0; }
    .page-wrapper { min-height: 100%; display: flex; flex-direction: column; }
    .wrap { flex: 1; } /* allow main content to grow */
    .page-footer {
      background-color: skyblue;
      color: darkblue;
      text-align:center;
      padding:10px 10px;
      font-size:12px;
      border-top: 2px solid darkblue;
    }
    
    /* Styles for the Global Editor panel (NEW) */
    #globalEditorContainer, #individualEditorContainer {
        margin-bottom: 15px; 
        background: #fff; 
        padding: 10px; 
        border-radius: 8px; 
        color: #111; 
        display: none; /* starts hidden */
        flex-direction: column;
    }
    #globalEditorContainer.active {
        display: flex; /* shows up when active */
    }
    #globalEditorControls, #individualEditorControls {
        display: flex; 
        gap: 15px; 
        flex-wrap: wrap;
    }
    #globalEditorControls .control-group, #individualEditorControls .control-group {
        display: flex; 
        gap: 15px; 
        flex-wrap: wrap; 
        background: #f5f5f5; 
        padding: 8px; 
        border-radius: 6px; 
        flex: 1;
        min-width: 250px;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
  <script src="https://unpkg.com/docx@8.3.2/build/index.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js"></script>
</head>

<body class="bg-image">
  <div class="toggle-bg" id="toggleBgBtn">üåÖ Hide / Show Background</div>

  <header style="color: darkred;">
    <h1 h1 style="color: darkred;">All-in-One Converter</h1>
    <div class="subtitle">Combine PDFs and convert between PDF ‚Üî Word ‚Üî Excel (and Images)</div>
  </header>

  <div class="wrap">
    <div class="grid" id="converterGrid"></div>
    <p style="text-align:center;opacity:.9;margin-top:30px">‚ö° Fast client-side converter</p>
  </div>

  <div class="overlay" id="fullscreenOverlay" aria-hidden="true">
    <div class="box" role="dialog" aria-modal="true">
      <h2 id="overlayTitle"></h2>
      
      <div id="individualEditorContainer">
          <h3 id="individualEditorTitle" style="margin-top:0; margin-bottom:10px;">Edit File: <span id="currentFileName" style="font-weight:400;"></span></h3>
          <div id="individualEditorControls">
              
              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Color Filters (Images Only)</h4>
                  <label style="display:block; min-width: 170px;">
                      Brightness: <span id="indBrightnessValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indBrightnessSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Contrast: <span id="indContrastValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indContrastSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Saturation: <span id="indSaturationValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indSaturationSlider" class="slider">
                  </label>
                  <button id="indResetFiltersBtn" class="secondary" style="height:36px; margin-top:5px; margin-left: 17px;">Reset Color</button>
              </div>

              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Transform (Images & PDFs)</h4>
                  <button id="indRotateBtn">Rotate 90¬∞ CW</button>
                  <button id="indFlipXBtn">Flip Horizontal</button>
                  <button id="indResetTransformBtn" class="secondary">Reset Transform</button>
              </div>
          </div>
          <div style="margin-top:10px; text-align:right;">
              <button id="indClearBtn" class="secondary">Clear Individual Edits</button>
              <button id="indDoneBtn">Done Editing</button>
          </div>
      </div>
      <div id="globalEditorContainer">
          <p style="margin-top:0; margin-bottom:10px; font-weight:700;">Global Edits (Applied to All Supported Files in the list)</p>
          <div id="globalEditorControls">
              
              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Color Filters (Images Only)</h4>
                  <label style="display:block; min-width: 170px;">
                      Brightness: <span id="brightnessValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="brightnessSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Contrast: <span id="contrastValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="contrastSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Saturation: <span id="saturationValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="saturationSlider" class="slider">
                  </label>
                  <button id="resetFiltersBtn" class="secondary" style="height:36px; margin-top:5px; margin-left: 17px;">Reset Color</button>
              </div>

              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Transform (Images & PDFs)</h4>
                  <button id="rotateBtn">Rotate 90¬∞ CW</button>
                  <button id="flipXBtn">Flip Horizontal</button>
                  <button id="resetTransformBtn" class="secondary">Reset Transform</button>
              </div>
          </div>
      </div>
      
      <div id="overlayControls" style="display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap">
        <div class="muted" id="overlayCount">0 files</div>
        <div style="display:flex;gap:8px">
          <button id="submitBtn">Submit</button>
          <button class="secondary" id="downloadBtn" style="display:none">Download</button>
          <button class="secondary" id="printBtn" style="display:none">Print</button>
          <button class="secondary" id="closeBtn">Back</button>
        </div>
      </div>

      <div id="overlayDrop" class="dropzone" style="margin-top:12px;">Drop files here to add (or click). Paste (Ctrl+V) images to add.</div>
      <div id="overlayPreview" class="preview-row"></div>
      <div id="postMsg" style="margin-top:12px"></div>
    </div>
  </div>

  <footer class="page-footer">
    <div class="footer-content">
      <b><p>¬© 2025 Your Website Name. All-in-One-Converter. Made with ‚ù§Ô∏è for fast client-side conversion.</p></b>
    </div>
  </footer>

  <script>
/* ---------- core setup: prevent default browser drag/drop behavior ---------- */
['dragenter','dragover','dragleave','drop'].forEach(ev => {
  window.addEventListener(ev, (e) => {
    if (e.target && (e.target.tagName === 'INPUT' || (e.target.closest && e.target.closest('input')))) return;
    e.preventDefault();
    e.stopPropagation();
  }, { passive:false });
});

/* ---------- converter definitions (UI data model) ---------- */
const converters = [
  // 1. Combine / Merge Files (PDF/Images)
  {id:'merge', label:'1. Combine / Merge Files (PDF/Images)', accept:'*'},
  // 2. PDF ‚Üí Word (.docx)
  {id:'pdf2docx', label:'2. PDF ‚Üí Word (.docx)', accept:'.pdf'},
  // 3. Word (.docx) ‚Üí PDF
  {id:'docx2pdf', label:'3. Word (.docx) ‚Üí PDF', accept:'.doc,.docx'},
  // 4. Excel (.xlsx) ‚Üí PDF
  {id:'xls2pdf', label:'4. Excel (.xlsx) ‚Üí PDF', accept:'.xls,.xlsx'},
  // 5. PDF ‚Üí Excel (.xlsx)
  {id:'pdf2xls', label:'5. PDF ‚Üí Excel (.xlsx)', accept:'.pdf'},
  // 6. Word (.docx) ‚Üí Excel (.xlsx)
  {id:'docx2xls', label:'6. Word (.docx) ‚Üí Excel (.xlsx)', accept:'.doc,.docx'},
  // 7. Excel (.xlsx) ‚Üí Word (.docx)
  {id:'xls2docx', label:'7. Excel (.xlsx) ‚Üí Word (.docx)', accept:'.xls,.xlsx'}
];

/* Insert the converter cards into the grid DOM element. */
const grid = document.getElementById('converterGrid');
converters.forEach(c=>{
  grid.insertAdjacentHTML('beforeend', `
    <section class="card" id="${c.id}">
      <h3>${c.label}</h3>
      <label class="dropzone" id="${c.id}Drop">
        Drop files here or
        <button class="secondary" data-click="choose" data-input="${c.id}Files">Choose files</button>
        <input id="${c.id}Files" type="file" accept="${c.accept}" multiple />
      </label>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="secondary" data-clear="${c.id}">Clear</button>
        <button class="secondary" data-full="${c.id}">Fullscreen</button>
      </div>
      <div class="file-list" id="${c.id}List">No file selected</div>
    </section>
  `);
});

/* ---------- small DOM helper utilities ---------- */
/* Simple get-by-id helper */
function byId(id){ return document.getElementById(id); }

/* Escape HTML to avoid injection in lists and messages */
function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/**
 * Format file size in bytes into human-readable format (KB, MB, GB).
 */
function formatFileSize(bytes){
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


/* Update the visible file list for a given card. */
function setListFromInput(id){
  const input = byId(id+'Files');
  const list = byId(id+'List');
  const files = Array.from(input.files || []);
  if(!files.length){
    list.innerHTML='No file selected';
    return;
  }
  list.innerHTML = files.map((f,i)=>`<div class="file-item"><div class="meta">${i+1}. ${escapeHtml(f.name)} (${formatFileSize(f.size)})</div><div><button class="secondary" data-remove="${id}" data-index="${i}">Remove</button></div></div>`).join('');
}

/* ---------- wire up dropzone, choose and clear behavior for each converter card ---------- */
converters.forEach(c=>{
  const drop = byId(c.id+'Drop');
  const input = byId(c.id+'Files');

  /* When user clicks dropzone label, open file picker (but not when clicking the inner Choose button) */
  drop.addEventListener('click', e=>{
    if(e.target && e.target.getAttribute && e.target.getAttribute('data-click')==='choose') return;
    input.click();
  });

  /* Choose button opens native file picker ‚Äî stops propagation so label click doesn't re-open */
  const chooseBtn = drop.querySelector('button[data-click="choose"]');
  chooseBtn.addEventListener('click', (e)=> { e.stopPropagation(); byId(e.target.getAttribute('data-input')).click(); });

  /* Add nice dragover visual when file is dragged over the drop area */
  ['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.add('dragover'); }, {passive:false}));
  ['dragleave','dragend','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.remove('dragover'); }, {passive:false}));

  /* When files are dropped into the dropzone, merge dropped items into existing input.files */
  drop.addEventListener('drop', e=>{
    const dt = new DataTransfer();
    Array.from(input.files || []).forEach(f => dt.items.add(f)); // keep existing files
    Array.from(e.dataTransfer.files || []).forEach(f => {
      dt.items.add(f);
    });
    input.files = dt.files;
    setListFromInput(c.id);
  });

  /* When native input changes (user picked files), update list display */
  input.addEventListener('change', ()=> setListFromInput(c.id));

  /* Clear button empties the file input and updates UI */
  const clearBtn = document.querySelector(`[data-clear="${c.id}"]`);
  if(clearBtn) clearBtn.addEventListener('click', ()=>{ input.value=''; setListFromInput(c.id); });
});

/* Remove single file from input when clicking 'Remove' in file-list */
document.addEventListener('click', (e)=>{
  const rem = e.target.closest('button[data-remove]');
  if(!rem) return;
  const idBase = rem.getAttribute('data-remove');
  const index = Number(rem.getAttribute('data-index'));
  const input = byId(idBase+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach((f,i)=>{ if(i!==index) dt.items.add(f); });
  input.files = dt.files;
  setListFromInput(idBase);
});


/* ---------- overlay & preview state and helpers ---------- */
/* Cached DOM for overlay controls */
const overlay = byId('fullscreenOverlay'), overlayTitle = byId('overlayTitle'), overlayCount = byId('overlayCount');
const overlayDrop = byId('overlayDrop'), overlayPreview = byId('overlayPreview');
const submitBtn = byId('submitBtn'), downloadBtn = byId('downloadBtn'), printBtn = byId('printBtn'), closeBtn = byId('closeBtn'), postMsg = byId('postMsg');
const globalEditorContainer = byId('globalEditorContainer');
const individualEditorContainer = byId('individualEditorContainer'); // NEW
const overlayBox = document.querySelector('.overlay .box');

let activeSection = null;
let lastResult = null; // store last conversion result { blob, filename, mime }

/* NEW GLOBAL STATE FOR IMAGE/PDF EDITS */
let globalMergeSettings = {
    rotation: 0, // 0, 90, 180, 270...
    flipX: 1,    // 1 (normal) or -1 (flipped)
    brightness: 0,
    contrast: 0,
    saturation: 0,
};

// NEW: Per-file settings storage
let individualFileSettings = {}; // { fileName: { rotation, flipX, brightness, contrast, saturation } }
let currentEditingFile = null; // Reference to the file currently being edited

let imageCache = {}; // Cache for loaded Image objects to avoid re-loading

/* openFullscreen: show overlay for chosen converter section */
function openFullscreen(sectionId){
  activeSection = sectionId;
  overlayTitle.textContent = document.querySelector('#'+sectionId+' h3').textContent;
  overlayCount.textContent = (byId(sectionId+'Files').files.length || 0) + ' files';
  lastResult = null;
  downloadBtn.style.display='none';
  printBtn.style.display='none';
  postMsg.innerHTML='';
  closeBtn.textContent = 'Back';
  closeBtn.onclick = closeFullscreen; // Restore default handler
  
  // Show/Hide Global Editor Controls, ensure individual is hidden
  individualEditorContainer.style.display = 'none'; // Hide individual editor
  overlayDrop.style.display = 'block'; // Ensure dropzone is visible
  overlayPreview.style.display = 'flex'; // Ensure preview is visible
  
  if (sectionId === 'merge') {
      globalEditorContainer.classList.add('active');
      wireGlobalControls(); 
      resetGlobalControls(false); // Reset settings but don't force a redraw yet
  } else {
      globalEditorContainer.classList.remove('active');
      resetGlobalControls(false); // Reset state when leaving merge section
  }

  renderOverlayPreviewFromInput(); // build preview thumbnails / list
  overlay.classList.add('open'); overlay.setAttribute('aria-hidden','false');
}

/* wire fullscreen button for each card */
document.querySelectorAll('[data-full]').forEach(btn=> btn.addEventListener('click', ()=> openFullscreen(btn.getAttribute('data-full')) ));

/* close overlay */
function closeFullscreen(){ 
  overlay.classList.remove('open'); 
  overlay.setAttribute('aria-hidden','true'); 
  activeSection=null; 
  globalEditorContainer.classList.remove('active');
  individualEditorContainer.style.display = 'none'; // Hide individual editor
  // Clear image cache and reset controls on close
  imageCache = {}; 
  resetGlobalControls(false);
}
closeBtn.addEventListener('click', closeFullscreen);

/* overlay drop handlers: allow adding files into overlay as well */
['dragenter','dragover'].forEach(ev=> overlayDrop.addEventListener(ev, e=>{ e.preventDefault(); overlayDrop.classList.add('dragover'); }, {passive:false}));
['dragleave','dragend','drop'].forEach(ev=> overlayDrop.addEventListener(ev, e=>{ e.preventDefault(); overlayDrop.classList.remove('dragover'); }, {passive:false}));

/* click overlay drop to open the file input for active section */
overlayDrop.addEventListener('click', ()=> { if(!activeSection) return; byId(activeSection+'Files').click(); });

/* drop on overlay: merge dropped files into current active section input */
overlayDrop.addEventListener('drop', e=>{
  e.preventDefault();
  overlayDrop.classList.remove('dragover');
  if(!activeSection) return;
  const input = byId(activeSection+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach(f=> dt.items.add(f));
  Array.from(e.dataTransfer.files || []).forEach(f=>{
    dt.items.add(f);
  });
  input.files = dt.files; setListFromInput(activeSection); renderOverlayPreviewFromInput();
  overlayCount.textContent = (input.files.length || 0) + ' files';
});

/* paste event: allow Ctrl+V of images into overlay (clipboard images) */
document.addEventListener('paste', (e)=>{
  if(!activeSection || !overlay.classList.contains('open')) return;
  if(activeSection !== 'merge') return; // Only allow paste for merge section

  const items = Array.from(e.clipboardData?.items || []);
  const fileItems = items.filter(it => it.kind === 'file');
  if(!fileItems.length) return;

  const input = byId(activeSection+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach(f=> dt.items.add(f));
  fileItems.forEach(it => { const file = it.getAsFile(); if(file) dt.items.add(file); });

  input.files = dt.files; setListFromInput(activeSection); renderOverlayPreviewFromInput(); overlayCount.textContent = (input.files.length || 0) + ' files';
});

/* when any converter input changes, update overlay preview if it's the active section */
converters.forEach(c=> byId(c.id+'Files').addEventListener('change', ()=>{ setListFromInput(c.id); if(activeSection === c.id) renderOverlayPreviewFromInput(); }));


/* ---------- SETTINGS HELPER (NEW/UPDATED) ---------- */

/**
 * Retrieves the effective settings for a given file, prioritizing individual edits.
 * @param {File} file The file object.
 * @returns {object} The combined settings object.
 */
function getSettings(file) {
    const defaults = { rotation: 0, flipX: 1, brightness: 0, contrast: 0, saturation: 0 };
    
    // 1. Individual Settings (highest priority)
    const individual = individualFileSettings[file.name];
    if (individual) {
        // Check if any individual edit has been made (by comparing to defaults)
        const hasIndividualEdit = Object.keys(defaults).some(k => individual[k] !== undefined && individual[k] !== defaults[k]);
        
        if (hasIndividualEdit) {
            return { ...defaults, ...individual };
        }
    }

    // 2. Global Settings (fallback for files without explicit individual edits)
    if (activeSection === 'merge') {
        return { ...defaults, ...globalMergeSettings };
    }
    
    // 3. Default (no edits)
    return defaults;
}


/* ---------- GLOBAL IMAGE EDITOR IMPLEMENTATION (NEW/UPDATED) ---------- */

/**
 * applyColorFilter: Canvas-based pixel manipulation for Brightness, Contrast, and Saturation.
 */
function applyColorFilter(canvas, brightness, contrast, saturation) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const b = brightness / 100 * 255;
    const c = (contrast + 100) / 100;
    const S = (saturation / 100) + 1;
    const L_R = 0.2126; const L_G = 0.7152; const L_B = 0.0722;

    for (let i = 0; i < data.length; i += 4) {
        let r = data[i], g = data[i + 1], b_val = data[i + 2];
        r = Math.max(0, Math.min(255, ((r + b - 128) * c) + 128));
        g = Math.max(0, Math.min(255, ((g + b - 128) * c) + 128));
        b_val = Math.max(0, Math.min(255, ((b_val + b - 128) * c) + 128));

        if (S !== 1) {
            const avg = r * L_R + g * L_G + b_val * L_B;
            r = avg * (1 - S) + r * S;
            g = avg * (1 - S) + g * S;
            b_val = avg * (1 - S) + b_val * S;
        }

        data[i] = Math.max(0, Math.min(255, r));
        data[i + 1] = Math.max(0, Math.min(255, g));
        data[i + 2] = Math.max(0, Math.min(255, b_val));
    }
    ctx.putImageData(imageData, 0, 0);
}


/**
 * Loads an image onto a canvas, applies transformations, and color filters 
 * based on the provided settings object. (Used for Images and Image Thumbnails)
 */
function applyImageEditsToCanvas(canvas, file, settings) {
    return new Promise(async (resolve, reject) => {
        // Use cached image if available
        let img = imageCache[file.name];
        if (!img) {
            img = new Image();
            const imgUrl = URL.createObjectURL(file);
            img.onload = () => {
                URL.revokeObjectURL(imgUrl);
                imageCache[file.name] = img; // Cache for next use
                processImage();
                resolve(img);
            };
            img.onerror = (e) => {
                URL.revokeObjectURL(imgUrl);
                reject(new Error("Image load failed for editing."));
            };
            img.src = imgUrl;
        } else {
            // Wait for image load if it was not done yet (should not happen if cached)
            if(!img.complete) {
                img.onload = processImage;
            } else {
                processImage();
            }
            resolve(img);
        }

        function processImage() {
            const ctx = canvas.getContext('2d');
            const w_orig = img.naturalWidth;
            const h_orig = img.naturalHeight;
            const { rotation, flipX, brightness, contrast, saturation } = settings;

            // 1. Calculate Canvas Dimensions based on Rotation
            const isRotated = (rotation % 180) !== 0; // 90 or 270 degrees
            let w = w_orig;
            let h = h_orig;
            if (isRotated) [w, h] = [h, w]; // Swap W/H if rotated

            canvas.width = w;
            canvas.height = h;
            ctx.clearRect(0, 0, w, h);

            // 2. Apply Geometric Transformations
            ctx.save();
            ctx.translate(w / 2, h / 2); // Move origin to center
            ctx.scale(flipX, 1); // Apply flip
            ctx.rotate(rotation * Math.PI / 180); // Apply rotation

            // 3. Draw the original image centered back
            ctx.drawImage(img, -w_orig / 2, -h_orig / 2, w_orig, h_orig);

            // 4. Apply Color Filters (on the manipulated image data)
            if (brightness !== 0 || contrast !== 0 || saturation !== 0) {
                applyColorFilter(canvas, brightness, contrast, saturation);
            }

            ctx.restore(); // Restore context state
        }
    });
}

// Reset the global editor controls to default state
function resetGlobalControls(redraw = true) {
    globalMergeSettings.rotation = 0;
    globalMergeSettings.flipX = 1;
    globalMergeSettings.brightness = 0;
    globalMergeSettings.contrast = 0;
    globalMergeSettings.saturation = 0;

    const brightnessSlider = byId('brightnessSlider');
    const contrastSlider = byId('contrastSlider');
    const saturationSlider = byId('saturationSlider');
    
    if (brightnessSlider) brightnessSlider.value = 0;
    if (contrastSlider) contrastSlider.value = 0;
    if (saturationSlider) saturationSlider.value = 0;
    
    if (byId('brightnessValue')) byId('brightnessValue').textContent = 0;
    if (byId('contrastValue')) byId('contrastValue').textContent = 0;
    if (byId('saturationValue')) byId('saturationValue').textContent = 0;
    
    if (redraw) renderOverlayPreviewFromInput();
}

let controlsWired = false;
function wireGlobalControls() {
    if (controlsWired) return;
    
    const brightnessSlider = byId('brightnessSlider');
    const contrastSlider = byId('contrastSlider');
    const saturationSlider = byId('saturationSlider');
    const brightnessValueSpan = byId('brightnessValue');
    const contrastValueSpan = byId('contrastValue');
    const saturationValueSpan = byId('saturationValue');
    const rotateBtn = byId('rotateBtn');
    const flipXBtn = byId('flipXBtn');
    const resetFiltersBtn = byId('resetFiltersBtn');
    const resetTransformBtn = byId('resetTransformBtn');

    const updateSettingsAndRedraw = () => {
        globalMergeSettings.brightness = Number(brightnessSlider.value);
        globalMergeSettings.contrast = Number(contrastSlider.value);
        globalMergeSettings.saturation = Number(saturationSlider.value);
        brightnessValueSpan.textContent = globalMergeSettings.brightness;
        contrastValueSpan.textContent = globalMergeSettings.contrast;
        saturationValueSpan.textContent = globalMergeSettings.saturation;
        renderOverlayPreviewFromInput();
    };

    brightnessSlider.addEventListener('input', updateSettingsAndRedraw);
    contrastSlider.addEventListener('input', updateSettingsAndRedraw);
    saturationSlider.addEventListener('input', updateSettingsAndRedraw);

    resetFiltersBtn.addEventListener('click', () => {
        globalMergeSettings.brightness = 0;
        globalMergeSettings.contrast = 0;
        globalMergeSettings.saturation = 0;
        brightnessSlider.value = 0;
        contrastSlider.value = 0;
        saturationSlider.value = 0;
        updateSettingsAndRedraw();
    });

    rotateBtn.addEventListener('click', () => {
        globalMergeSettings.rotation = (globalMergeSettings.rotation + 90) % 360;
        renderOverlayPreviewFromInput();
    });
    
    flipXBtn.addEventListener('click', () => {
        globalMergeSettings.flipX *= -1;
        renderOverlayPreviewFromInput();
    });
    
    resetTransformBtn.addEventListener('click', () => {
        globalMergeSettings.rotation = 0;
        globalMergeSettings.flipX = 1;
        renderOverlayPreviewFromInput();
    });

    controlsWired = true;
}

/* ---------- INDIVIDUAL FILE EDITOR IMPLEMENTATION (NEW) ---------- */

const indBrightnessSlider = byId('indBrightnessSlider');
const indContrastSlider = byId('indContrastSlider');
const indSaturationSlider = byId('indSaturationSlider');
const indBrightnessValueSpan = byId('indBrightnessValue');
const indContrastValueSpan = byId('indContrastValue');
const indSaturationValueSpan = byId('indSaturationValue');
const indRotateBtn = byId('indRotateBtn');
const indFlipXBtn = byId('indFlipXBtn');
const indResetFiltersBtn = byId('indResetFiltersBtn');
const indResetTransformBtn = byId('indResetTransformBtn');
const currentFileNameSpan = byId('currentFileName');
const indDoneBtn = byId('indDoneBtn');
const indClearBtn = byId('indClearBtn');

function openIndividualEditor(fileIndex, file) {
    if (activeSection !== 'merge') return;
    
    const name = file.name.toLowerCase();
    const isSupported = name.endsWith('.pdf') || file.type.startsWith('image/');
    if (!isSupported) {
        alert(`The file type (${file.type || name.split('.').pop()}) is not supported for individual editing.`);
        return;
    }

    currentEditingFile = file;
    
    // Hide global elements
    globalEditorContainer.classList.remove('active');
    overlayDrop.style.display = 'none';
    
    // Show individual editor
    individualEditorContainer.style.display = 'flex';
    currentFileNameSpan.textContent = file.name;
    
    // Get current effective settings (individual or global)
    const settings = getSettings(file);
    
    // Ensure the file has a key in individualFileSettings, defaulting to its current effective settings
    if (!individualFileSettings[file.name]) {
        individualFileSettings[file.name] = { 
            rotation: settings.rotation, 
            flipX: settings.flipX, 
            brightness: settings.brightness, 
            contrast: settings.contrast, 
            saturation: settings.saturation, 
        };
    }

    // Set initial slider values
    indBrightnessSlider.value = settings.brightness;
    indContrastSlider.value = settings.contrast;
    indSaturationSlider.value = settings.saturation;
    indBrightnessValueSpan.textContent = settings.brightness;
    indContrastValueSpan.textContent = settings.contrast;
    indSaturationValueSpan.textContent = settings.saturation;

    // Update the preview area to show only the selected file
    renderSingleFilePreview(file);

    // Wire up controls (or re-wire for the current file)
    wireIndividualControls(file);
}

function renderSingleFilePreview(file) {
    overlayPreview.style.display = 'flex';
    overlayPreview.innerHTML = '';
    overlayCount.textContent = `Editing: ${file.name}`;

    const card = document.createElement('div'); card.className='preview-card'; 
    card.style.width='300px'; card.style.height='300px'; 
    card.style.cursor='default'; card.style.margin='20px auto';
    card.draggable = false;
    
    const previewEl = document.createElement('div');
    previewEl.style.minHeight='200px'; 
    previewEl.style.maxHeight='200px';
    previewEl.style.display='flex';
    previewEl.style.alignItems='center';
    previewEl.style.justifyContent='center';
    previewEl.style.position='relative';
    
    const canvas = document.createElement('canvas'); 
    canvas.style.maxWidth='100%'; canvas.style.maxHeight='100%'; 
    previewEl.appendChild(canvas);
    
    // Get current settings for the single file
    const settings = individualFileSettings[file.name] || getSettings(file);
    
    // The individual editor only supports Image/PDF files. PDF preview logic for rotation/flip 
    // is complex and already handled in renderOverlayPreviewFromInput, but here we only draw 
    // to a canvas. For simplicity and reliability in the single preview mode, we only render 
    // images accurately with color filters. PDF preview here will be basic/best effort.
    
    const isImageFile = file.name.toLowerCase().match(/\.(jpe?g|png|gif|bmp|webp)$/) || (file.type && file.type.startsWith('image/'));
    
    if (isImageFile) {
        applyImageEditsToCanvas(canvas, file, settings).catch(e => {
            console.error("Single File Preview Error:", e);
            previewEl.innerHTML = '<div class="muted">Preview Error</div>';
        });
    } else if (file.name.toLowerCase().endsWith('.pdf')) {
        // Render PDF preview (using logic from renderOverlayPreviewFromInput)
        (async ()=>{
            try{
              const ab = await file.arrayBuffer();
              const pdf = await pdfjsLib.getDocument({data:ab}).promise;
              const page = await pdf.getPage(1);
              
              const { rotation, flipX } = settings;
              const isRotated = rotation % 180 !== 0; 
              
              const viewport = page.getViewport({ scale: 0.8, rotation: rotation }); 

              // Scale to fit the 300x300 preview box (max 200px height for canvas)
              const ratio = Math.min(300/viewport.width, 200/viewport.height, 1);
              const scaled = page.getViewport({ scale: ratio, rotation: rotation });

              canvas.width = scaled.width; 
              canvas.height = scaled.height;

              const ctx = canvas.getContext('2d');
              ctx.save();
              if(flipX === -1) {
                 if (isRotated) {
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width / 2, -canvas.height / 2);
                 } else {
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                 }
              }

              await page.render({ canvasContext: ctx, viewport: scaled }).promise;
              ctx.restore(); 

            }catch(e){ previewEl.innerHTML = '<div class="muted">PDF Preview Error</div>'; }
        })();
    } else {
        previewEl.innerHTML = `<div class="muted">Preview not available for this type.</div>`;
    }


    const title = document.createElement('div'); title.className='muted'; title.style.marginTop='6px'; title.textContent = `File: ${file.name}`;
    card.appendChild(previewEl); card.appendChild(title);
    overlayPreview.appendChild(card);
}


let individualControlsWired = false;
function wireIndividualControls(file) {
    const key = file.name;
    
    const updateSettingsAndRedraw = () => {
        const settings = individualFileSettings[key];
        settings.brightness = Number(indBrightnessSlider.value);
        settings.contrast = Number(indContrastSlider.value);
        settings.saturation = Number(indSaturationSlider.value);
        
        indBrightnessValueSpan.textContent = settings.brightness;
        indContrastValueSpan.textContent = settings.contrast;
        indSaturationValueSpan.textContent = settings.saturation;
        
        renderSingleFilePreview(file); // Redraw the single file preview
    };
    
    const handleResetFilters = () => {
         individualFileSettings[key].brightness = 0;
         individualFileSettings[key].contrast = 0;
         individualFileSettings[key].saturation = 0;
         indBrightnessSlider.value = 0;
         indContrastSlider.value = 0;
         indSaturationSlider.value = 0;
         updateSettingsAndRedraw();
    };

    const handleRotate = () => {
         let settings = individualFileSettings[key];
         settings.rotation = ((settings.rotation || 0) + 90) % 360;
         renderSingleFilePreview(file);
    };
    
    const handleFlipX = () => {
         let settings = individualFileSettings[key];
         settings.flipX = (settings.flipX || 1) * -1;
         renderSingleFilePreview(file);
    };
    
    const handleResetTransform = () => {
         individualFileSettings[key].rotation = 0;
         individualFileSettings[key].flipX = 1;
         renderSingleFilePreview(file);
    };

    const handleClearEdits = () => {
        delete individualFileSettings[key];
        closeIndividualEditor();
    };


    if (individualControlsWired) {
         // Re-wire/update listeners for the current file
         indBrightnessSlider.oninput = updateSettingsAndRedraw;
         indContrastSlider.oninput = updateSettingsAndRedraw;
         indSaturationSlider.oninput = updateSettingsAndRedraw;
         
         indResetFiltersBtn.onclick = handleResetFilters;
         indRotateBtn.onclick = handleRotate;
         indFlipXBtn.onclick = handleFlipX;
         indResetTransformBtn.onclick = handleResetTransform;
         
         indDoneBtn.onclick = closeIndividualEditor;
         indClearBtn.onclick = handleClearEdits;

         return; 
    }
    
    indBrightnessSlider.addEventListener('input', updateSettingsAndRedraw);
    indContrastSlider.addEventListener('input', updateSettingsAndRedraw);
    indSaturationSlider.addEventListener('input', updateSettingsAndRedraw);

    indResetFiltersBtn.addEventListener('click', handleResetFilters);
    indRotateBtn.addEventListener('click', handleRotate);
    indFlipXBtn.addEventListener('click', handleFlipX);
    indResetTransformBtn.addEventListener('click', handleResetTransform);

    indDoneBtn.addEventListener('click', closeIndividualEditor);
    indClearBtn.addEventListener('click', handleClearEdits);

    individualControlsWired = true;
}

function closeIndividualEditor() {
    currentEditingFile = null;
    individualEditorContainer.style.display = 'none';
    
    // Restore global editor and preview list view
    if (activeSection === 'merge') {
        globalEditorContainer.classList.add('active'); // Restore global editor
    }
    overlayDrop.style.display = 'block';
    
    // Restore file count
    overlayCount.textContent = (byId(activeSection+'Files').files.length || 0) + ' files';
    
    // Redraw the main preview with updated edits
    renderOverlayPreviewFromInput();
}


/* ---------- render overlay preview (thumbnails or lightweight list) ---------- */
async function renderOverlayPreviewFromInput(){
  overlayPreview.innerHTML=''; postMsg.innerHTML=''; lastResult=null; downloadBtn.style.display='none'; printBtn.style.display='none';
  if(!activeSection) return;
  const input = byId(activeSection+'Files');
  const files = Array.from(input.files || []);
  overlayCount.textContent = `${files.length} file(s)`;
  if(!files.length){
    overlayPreview.innerHTML = `<div class="muted" style="margin-top:12px">No files. Drop files or use Choose.</div>`;
    return;
  }

  const LARGE_THRESHOLD = 500;
  const THUMB_LIMIT = 120;

  if(files.length > LARGE_THRESHOLD){
    // Build compact textual list for very large sets
    const container = document.createElement('div'); container.className='light-list';
    files.forEach((f,i)=>{
      const row = document.createElement('div'); row.className='list-row'; row.draggable = true; row.dataset.index = i;
      const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
      const handle = document.createElement('div'); handle.className='drag-handle'; handle.textContent='‚ò∞';
      left.appendChild(handle);
      const meta = document.createElement('div'); meta.textContent = `${i+1}. ${f.name} (${formatFileSize(f.size)})`; meta.style.marginLeft='8px';
      left.appendChild(meta);
      const right = document.createElement('div');
      
      // New: Add Edit button for merge section
      if (activeSection === 'merge') {
          const editBtn = document.createElement('button'); editBtn.textContent='Edit'; editBtn.className='secondary'; editBtn.style.marginRight='8px';
          editBtn.addEventListener('click', (e)=> { e.stopPropagation(); openIndividualEditor(i, f); });
          right.appendChild(editBtn);
      }
      
      const viewBtn = document.createElement('button'); viewBtn.textContent='View'; viewBtn.addEventListener('click', (e)=> { e.stopPropagation(); openFileInNewTab(f); });
      const delBtn = document.createElement('button'); delBtn.className='secondary'; delBtn.textContent='Delete'; delBtn.addEventListener('click', (e)=> { e.stopPropagation(); overlayRemove(i); });
      right.appendChild(viewBtn); right.appendChild(delBtn);
      row.appendChild(left); row.appendChild(right);
      container.appendChild(row);
      // drag-drop reordering handlers within overlay list
      row.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', i); row.classList.add('dragging'); });
      row.addEventListener('dragend', ()=> row.classList.remove('dragging'));
      row.addEventListener('dragover', ev=> ev.preventDefault());
      row.addEventListener('drop', ev=>{ ev.preventDefault(); const from = Number(ev.dataTransfer.getData('text/plain')); const to = Number(row.dataset.index); reorderFiles(input, from, to); renderOverlayPreviewFromInput(); });
    });
    overlayPreview.appendChild(container);
    return;
  }

  // For moderate number of files, create cards with thumbnail/content preview
  for(let i=0;i<files.length;i++){
    const f = files[i];
    const card = document.createElement('div'); card.className='preview-card'; card.draggable = true; card.dataset.index = i; card.style.color='#111';
    
    // NEW: Individual Edit Click Handler
    if (activeSection === 'merge') {
        card.addEventListener('click', ()=> openIndividualEditor(i, f)); // Click photo to edit
        card.style.cursor = 'pointer';
        if (individualFileSettings[f.name]) {
             card.classList.add('individual-edit'); // Add border if edited
        } else {
             card.classList.remove('individual-edit');
        }
    }
    
    // Drag-reorder support for preview cards
    card.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', i); card.classList.add('dragging'); });
    card.addEventListener('dragend', ()=> card.classList.remove('dragging'));
    card.addEventListener('dragover', ev=> ev.preventDefault());
    card.addEventListener('drop', ev=>{ ev.preventDefault(); const from = Number(ev.dataTransfer.getData('text/plain')); const to = Number(card.dataset.index); reorderFiles(byId(activeSection+'Files'), from, to); renderOverlayPreviewFromInput(); });

    const previewEl = document.createElement('div');
    previewEl.style.minHeight='90px';
    previewEl.style.display='flex';
    previewEl.style.alignItems='center';
    previewEl.style.justifyContent='center';
    previewEl.style.position='relative';

    const name = f.name.toLowerCase();
    
    // Check if the file is an image
    const isImageFile = name.match(/\.(jpe?g|png|gif|bmp|webp)$/) || (f.type && f.type.startsWith('image/'));

    // Get the effective settings (individual or global)
    const settings = getSettings(f);

    // show image thumbnail for common image types
    if(i < THUMB_LIMIT && isImageFile){
      const canvas = document.createElement('canvas'); 
      canvas.style.maxWidth='100%'; canvas.style.maxHeight='90px'; 
      previewEl.appendChild(canvas);
      
      // Apply global/individual edits (including color filters) to the thumbnail
      applyImageEditsToCanvas(canvas, f, settings).catch(e => {
        console.error("Thumbnail edit failed:", e);
        previewEl.innerHTML = '<div class="muted">Image Preview Error</div>';
      });

    } else if(i < THUMB_LIMIT && name.endsWith('.pdf')){
      // For PDFs, render first page thumbnail using pdf.js
      const canvas = document.createElement('canvas'); canvas.style.maxWidth='100%'; canvas.style.maxHeight='90px'; previewEl.appendChild(canvas);
      (async ()=>{
        try{
          const ab = await f.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({data:ab}).promise;
          const page = await pdf.getPage(1);
          
          const { rotation, flipX } = settings;
          const isRotated = rotation % 180 !== 0; // 90 or 270 degrees
          
          // 1. Calculate PDF viewport with rotation applied
          const viewport = page.getViewport({ scale: 0.8, rotation: rotation }); 

          // 2. Adjust canvas size based on final rotated dimensions
          const ratio = Math.min(150/viewport.width, 90/viewport.height, 1);
          const scaled = page.getViewport({ scale: ratio, rotation: rotation });

          canvas.width = scaled.width; 
          canvas.height = scaled.height;

          const ctx = canvas.getContext('2d');

          // 3. Apply flip transformation before rendering PDF page content
          ctx.save();
          if(flipX === -1) {
             // For flip, translate to the center and flip the x-axis, then translate back
             if (isRotated) {
                // If rotated and flipped: need to flip around the new center
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(-1, 1);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);
             } else {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
             }
          }

          // Render PDF page with the calculated rotated viewport
          await page.render({ canvasContext: ctx, viewport: scaled }).promise;
          ctx.restore(); // Restore context state

        }catch(e){ previewEl.innerHTML = '<div class="muted">Preview error</div>'; }
      })();
    } else {
      // Fallback: display file extension as a badge
      const ext = (f.name.split('.').pop() || '').toUpperCase();
      const icon = document.createElement('div'); icon.innerHTML = `<div style="font-weight:700;font-size:18px">${escapeHtml(ext)}</div>`; previewEl.appendChild(icon);
    }

    // Added file size to the title line
    const title = document.createElement('div'); title.className='muted'; title.style.marginTop='6px'; title.textContent = `${i+1}. ${f.name} (${formatFileSize(f.size)})`;
    const actions = document.createElement('div'); actions.className='preview-actions';
    
    // Add View and Delete buttons (Edit is handled by card click now)
    const viewBtn = document.createElement('button'); viewBtn.textContent='View'; viewBtn.addEventListener('click', (e)=> { e.stopPropagation(); openFileInNewTab(f); });
    const delBtn = document.createElement('button'); delBtn.className='secondary'; delBtn.textContent='Delete'; delBtn.addEventListener('click', (e)=> { e.stopPropagation(); overlayRemove(i); });
    actions.appendChild(viewBtn); actions.appendChild(delBtn);

    card.appendChild(previewEl); card.appendChild(title); card.appendChild(actions);
    overlayPreview.appendChild(card);
  }
}

/* reorderFiles: reorders files inside an <input type=file> by index */
function reorderFiles(inputEl, fromIndex, toIndex){
  const files = Array.from(inputEl.files || []);
  if(fromIndex < 0 || toIndex < 0 || fromIndex >= files.length || toIndex > files.length) return;
  const file = files.splice(fromIndex,1)[0];
  files.splice(toIndex,0,file);
  const dt = new DataTransfer();
  files.forEach(f=> dt.items.add(f));
  inputEl.files = dt.files;
  setListFromInput(activeSection);
  
  // NOTE: Reordering can mess up individualFileSettings if keyed by index. 
  // Since we key by file.name, we don't need to update individualFileSettings.
}

/* Remove (delete) a single file from the active section input */
function overlayRemove(index){
  if(!activeSection) return;
  const input = byId(activeSection+'Files');
  const files = Array.from(input.files || []);
  const fileToRemove = files[index];
  
  // Remove file from individual settings if it exists
  if (fileToRemove && individualFileSettings[fileToRemove.name]) {
      delete individualFileSettings[fileToRemove.name];
  }
  
  const dt = new DataTransfer();
  files.forEach((f,i)=> { if(i!==index) dt.items.add(f); });
  input.files = dt.files;
  setListFromInput(activeSection);
  renderOverlayPreviewFromInput();
  overlayCount.textContent = (input.files.length || 0) + ' files';
}

/* Open a file in a new tab using an object URL */
function openFileInNewTab(file){
  const url = URL.createObjectURL(file);
  window.open(url,'_blank');
  // revoke later to release memory (timeout keeps it open briefly)
  setTimeout(()=> URL.revokeObjectURL(url), 30000);
}

/* ---------- conversion helpers (utilities) ---------- */
/* Utility: read a File as ArrayBuffer (promisified FileReader) */
const readAsArrayBuffer = (file) => new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(file); });

/* ---------- conversion implementations (UPDATED) ---------- */

/* MERGE ANY FILE (PDFs and Images) (client-side using pdf-lib) */
async function doMergeAnyFileToPdf(){
  const input = byId('mergeFiles');
  if(!input.files.length) throw new Error('No files selected');
  const files = Array.from(input.files);

  const pdfDoc = await PDFLib.PDFDocument.create();
  const unsupportedFiles = [];
  const filesToProcess = files.sort((a,b)=>a.name.localeCompare(b.name));

  const [pageW, pageH] = [595.28, 841.89];
  const margin = 50;
  const maxW = pageW - margin*2;
  const maxH = pageH - margin*2;
  const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
  
  // const { rotation: globalRotation, flipX: globalFlipX } = globalMergeSettings; // OLD

  for(const f of filesToProcess){
    try{
      const type = f.type.toLowerCase();
      const filename = f.name.toLowerCase();
      
      // Get the effective settings for the current file
      const { rotation, flipX, brightness, contrast, saturation } = getSettings(f);

      if(type === 'application/pdf' || filename.endsWith('.pdf')){
        // --- Process PDF: Apply File-Specific Transforms (Rotation/Flip) ---
        const bytes = await f.arrayBuffer();
        const src = await PDFLib.PDFDocument.load(bytes);
        
        // Copy pages
        const pages = await pdfDoc.copyPages(src, src.getPageIndices());
        
        // Apply rotation and flip to each page before adding it to the new document
        pages.forEach(p=> {
            // Apply rotation (0, 90, 180, 270)
            if (rotation !== 0) {
                p.setRotation(PDFLib.degrees(rotation)); 
            }

            // Apply flip transformation
            if (flipX === -1) {
                // Horizontal flip (scaleX=-1) combined with a translation to bring content back on the page
                const width = p.getWidth(); 
                p.setTransformationMatrix([
                    -1, 0,
                     0, 1,
                    width, 0,
                ]);
            }
            pdfDoc.addPage(p);
        });

      } else if(type.startsWith('image/') || filename.match(/\.(jpe?g|png|gif|bmp|webp)$/)){
        // --- Process Image with File-Specific Edits (Transforms + Color Filters) ---
        
        // 1. Create a temporary canvas for full-resolution drawing and editing
        const tempCanvas = document.createElement('canvas');
        const img = imageCache[f.name] || new Image();
        if (!img.src) img.src = URL.createObjectURL(f);
        
        // Ensure image is loaded before processing
        await new Promise(resolve => {
            if (img.complete) return resolve();
            img.onload = resolve;
        });

        // 2. Apply all file-specific edits (rotation, flip, color filters) to the canvas
        // We pass the file-specific settings here
        await applyImageEditsToCanvas(tempCanvas, f, { rotation, flipX, brightness, contrast, saturation });

        // 3. Get the edited image data as a PNG ArrayBuffer (high quality)
        const arr = await new Promise((resolve, reject) => {
            tempCanvas.toBlob(blob => {
                if(!blob) return reject(new Error('Canvas to Blob failed.'));
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(blob);
            }, 'image/png'); 
        });

        // 4. Embed and draw the edited image to a new PDF page
        const embedded = await pdfDoc.embedPng(arr);
        const page = pdfDoc.addPage([pageW, pageH]);
        const imgDims = embedded.scale(1);
        
        // Calculate scale to fit within page margins
        const scale = Math.min(maxW / imgDims.width, maxH / imgDims.height, 1);
        const drawW = imgDims.width * scale;
        const drawH = imgDims.height * scale;
        const x = (pageW - drawW)/2;
        const y = (pageH - drawH)/2;
        page.drawImage(embedded, { x, y, width: drawW, height: drawH });

      } else {
        // --- Unsupported File Type: Add a simple page with a note ---
        unsupportedFiles.push(f.name);
        const page = pdfDoc.addPage([pageW, pageH]);
        page.drawText(`File skipped (unsupported for merging): ${f.name}`, { x: 50, y: pageH - 50, size: 16, font: font });
        page.drawText(`Type: ${f.type || 'unknown'}`, { x: 50, y: pageH - 70, size: 12, font: font });
        page.drawText('Supported types are PDF and Images (JPG/PNG/etc.)', { x: 50, y: pageH - 100, size: 12, font: font });
      }
    }catch(e){
      console.error(`Error processing file ${f.name}:`, e);
      unsupportedFiles.push(f.name + ' (Processing Error)');
    }
  }

  if(pdfDoc.getPages().length === 0) throw new Error('No supported files were processed.');

  const merged = await pdfDoc.save();
  const filename = unsupportedFiles.length ? 'merged-with-skips.pdf' : 'merged.pdf';

  return { blob: new Blob([merged],{type:'application/pdf'}), filename: filename, mime: 'application/pdf' };
}


/* PDF -> DOCX (client-side approximation) */
async function doPdfToDocx() {
  const inEl = document.getElementById('pdf2docxFiles'); 
  if (!inEl || !inEl.files[0]) throw new Error('Please select a PDF file first.'); 
  if (!window.pdfjsLib) throw new Error('The PDF.js library failed to load.');

  if (!window.docx) {
    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = "https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js";
      script.onload = () => { if (window.docx) resolve(); else reject(new Error("DOCX script failed to define window.docx.")); };
      script.onerror = () => reject(new Error("Failed to load DOCX library from CDN."));
      document.head.appendChild(script); 
    });
  }

  const { Document, Paragraph, Packer } = window.docx;
  const file = inEl.files[0];
  const fbytes = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: fbytes }).promise;
  const paragraphs = [];

  for (let p = 1; p <= pdf.numPages; p++) {
    const page = await pdf.getPage(p);                
    const content = await page.getTextContent();      
    const text = content.items.map(i => i.str || '').join(' '); 
    paragraphs.push(new Paragraph(`‚Äî Page ${p} ‚Äî`));
    paragraphs.push(new Paragraph(text.trim()));     
  }

  const doc = new Document({ sections: [{ children: paragraphs }] });
  const blob = await Packer.toBlob(doc);
  const filename = (file.name.replace(/\.pdf$/i, '') || 'document') + '.docx';
  const mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';

  return { blob, filename, mime };
}


/* DOCX -> PDF (client-side approximation) */
async function doDocxToPdf(){
  const inEl = byId('docx2pdfFiles');
  if(!inEl || !inEl.files[0]) throw new Error('Pick a .docx file');
  const ab = await readAsArrayBuffer(inEl.files[0]);
  const result = await mammoth.convertToHtml({ arrayBuffer: ab });
  const tmp = document.createElement('div'); tmp.innerHTML = result.value;

  const textBlocks = Array.from(tmp.querySelectorAll('p, h1, h2, h3, h4, h5, h6')).map(el=> ({ text: el.textContent, margin:[0,4,0,4] }));
  const docDef = { content: textBlocks, defaultStyle:{ fontSize:11 } };

  return new Promise((res,rej)=> pdfMake.createPdf(docDef).getBlob(blob => res({ blob, filename: (inEl.files[0].name.replace(/\.docx$/i,'')||'document') + '.pdf', mime:'application/pdf' })));
}

/* XLSX -> PDF (client-side) */
async function doXlsxToPdf(){
  const inEl = byId('xls2pdfFiles'); if(!inEl || !inEl.files[0]) throw new Error('Pick an .xlsx file');
  const ab = await readAsArrayBuffer(inEl.files[0]);
  const wb = XLSX.read(ab, { type:'array' });
  const wsName = wb.SheetNames[0];
  const ws = wb.Sheets[wsName];
  const data = XLSX.utils.sheet_to_json(ws, { header:1, blankrows:false });

  // Convert rows to pdfmake table body
  const tableBody = data.map(r=> r.map(cell => ({ text: (cell==null?'':String(cell)), margin:[2,2,2,2] })));
  const docDef = { content:[{ text: wsName, style:'header', margin:[0,0,0,8] }, { table:{ body: tableBody, headerRows:1 } }], styles:{ header:{ fontSize:14, bold:true } } };

  return new Promise((res,rej)=> pdfMake.createPdf(docDef).getBlob(blob => res({ blob, filename: (inEl.files[0].name.replace(/\.xlsx$/i,'')||'sheet') + '.pdf', mime:'application/pdf' })));
}

/* PDF -> XLSX (text extraction) */
async function doPdfToXlsx(){
  const inEl = byId('pdf2xlsFiles'); if(!inEl || !inEl.files[0]) throw new Error('Pick a PDF file');
  const ab = await readAsArrayBuffer(inEl.files[0]);
  const pdf = await pdfjsLib.getDocument({data:ab}).promise;
  const rows=[];
  for(let p=1;p<=pdf.numPages;p++){
    const page = await pdf.getPage(p);
    const content = await page.getTextContent();
    const line = content.items.map(i=>i.str).join(' ');
    rows.push([`Page ${p}`, line]);
  }
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet([['Page','Content'], ...rows]);
  XLSX.utils.book_append_sheet(wb, ws, 'Extracted');
  const out = XLSX.write(wb, { type:'array', bookType:'xlsx' });
  return { blob: new Blob([out],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), filename: (inEl.files[0].name.replace(/\.pdf$/i,'')||'pdf') + '.xlsx', mime:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' };
}

/* DOCX -> XLSX (paragraph extraction) */
async function doDocxToXlsx(){
  const inEl = byId('docx2xlsFiles'); if(!inEl || !inEl.files[0]) throw new Error('Pick a .docx file');
  const ab = await readAsArrayBuffer(inEl.files[0]);
  const result = await mammoth.extractRawText({ arrayBuffer: ab });
  const lines = result.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const data = [['Paragraph']].concat(lines.map(s=>[s]));
  const wb = XLSX.utils.book_new();
  const ws = XLSX.utils.aoa_to_sheet(data);
  XLSX.utils.book_append_sheet(wb, ws, 'Paragraphs');
  const out = XLSX.write(wb, { type:'array', bookType:'xlsx' });
  return { blob: new Blob([out],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}), filename: (inEl.files[0].name.replace(/\.docx$/i,'')||'doc') + '.xlsx', mime:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' };
}

/* XLSX -> DOCX (table creation) */
async function doXlsxToDocx(){
  const inEl = byId('xls2docxFiles'); if(!inEl || !inEl.files[0]) throw new Error('Pick an .xlsx file');
  const ab = await readAsArrayBuffer(inEl.files[0]);
  const wb = XLSX.read(ab, { type:'array' });
  const wsName = wb.SheetNames[0];
  const ws = wb.Sheets[wsName];
  const data = XLSX.utils.sheet_to_json(ws, { header:1, blankrows:false });

  const { Document, Packer, Paragraph, Table, TableRow, TableCell, WidthType, AlignmentType } = docx;
  const rows = (data.length ? data : [['Empty']]).map(r => new TableRow({
    children: (r.length ? r : ['']).map(cell => new TableCell({ children:[ new Paragraph(String(cell)) ], width:{ size: 100/(data[0]?.length||1), type: WidthType.PERCENTAGE } }))
  }));
  const table = new Table({ rows, width: { size: 100, type: WidthType.PERCENTAGE } });
  const documentObj = new Document({ sections:[{ children:[ new Paragraph({ text: wsName, alignment: AlignmentType.CENTER }), table ] }]});
  const blob = await Packer.toBlob(documentObj);
  return { blob, filename: (inEl.files[0].name.replace(/\.xlsx$/i,'')||'sheet') + '.docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' };
}

/* ---------- mapping: section id -> function ---------- */
const sectionToAction = {
  merge: doMergeAnyFileToPdf,
  pdf2docx: doPdfToDocx,
  docx2pdf: doDocxToPdf,
  xls2pdf: doXlsxToPdf,
  pdf2xls: doPdfToXlsx,
  docx2xls: doDocxToXlsx,
  xls2docx: doXlsxToDocx
};

/* ---------- Submit handler: call conversion and surface result ---------- */
submitBtn.addEventListener('click', async ()=>{
  if(!activeSection) return alert('No active converter.');
  submitBtn.disabled=true;
  submitBtn.textContent='Working...';
  postMsg.innerHTML='';
  downloadBtn.style.display='none';
  printBtn.style.display='none';
  try{
    const func = sectionToAction[activeSection];
    if(!func) throw new Error('No action found.');
    const result = await func();
    lastResult = result;
    postMsg.innerHTML = `<div class="success" style="margin-top:8px">Done: ${escapeHtml(result.filename)}</div>`;
    downloadBtn.style.display=''; downloadBtn.onclick = ()=> saveBlob(result.blob, result.filename);
    if(result.mime === 'application/pdf'){
      printBtn.style.display='';
      printBtn.onclick = ()=> {
        const url = URL.createObjectURL(result.blob);
        const w = window.open(url,'_blank');
        // small delay to allow new tab to load the PDF then call print
        setTimeout(()=> w.print(),700);
        setTimeout(()=> URL.revokeObjectURL(url),30000);
      };
    } else {
      printBtn.style.display='none';
      printBtn.onclick = null;
    }
  }catch(err){
    console.error(err);
    postMsg.innerHTML = `<div class="error" style="margin-top:8px">Error: ${escapeHtml(err.message || String(err))}</div>`;
  } finally{
    submitBtn.disabled=false;
    submitBtn.textContent='Submit';
  }
});

/* ---------- UI: background toggle button ---------- */
const toggleBtn = document.getElementById('toggleBgBtn');
const body = document.body;
let bgVisible = true; // starts with image shown

toggleBtn.addEventListener('click', () => {
  if (bgVisible) {
    // switch to gradient (remove image)
    body.classList.remove('bg-image');
    bgVisible = false;
    toggleBtn.textContent = "üåÖ Show Background";
  } else {
    // set image background class
    body.classList.add('bg-image');
    bgVisible = true;
    toggleBtn.textContent = "üåÖ Hide Background";
  }
});

/* ---------- helpers ---------- */
/* saveBlob: save a Blob to user's disk using FileSaver (or fallback anchor) */
function saveBlob(blob, filename){
  try{
    saveAs(blob, filename); // FileSaver library
  }catch(e){
    // fallback: create anchor element and trigger download
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
}

/* initialize file-list UI for each converter at page load */
converters.forEach(c=> setListFromInput(c.id));
</script>
</body>
</html>

